<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <h1># 함수형 프로그래밍 </h1>

    부수효과를 미워하며 순수함수를 만든다.
    조합성을 강조한다. 모듈화 수준을 높인다

    오류가 적고 안정성 높인다
    모듈화 수준이 높다 => 생산성 높인다 

    <!-- 객체지향 프로ㅓ그래밍  -->
    - 데이터를 먼저 만들고 데이터에 따른 메서드를 제작
    duck.moveLeft()
    dog.moveRight()

    <!-- 함수형 프로그래밍 -->
    - 함수를 먼저 만들고 데이터를 인자로 넣어서 동작하도록 만듦
    moveLeft(dog) 
    moveRight(duck)

    1. 항상 동일한 결과를 리턴함
    2. 외부 상태에 영향을 미치지 않음(부수효과)
    3. 평가 시점이 중요하지않음 
    

<script>

// 순수함수 => 
// 1. 항상 동일한 결과를 리턴함
// 2. 외부 상태에 영향을 미치지 않음(부수효과)
// 3. 평가 시점이 중요하지않음 
function add(a, b) {
    return a + b;
}

console.log( add(10, 5) )


// 순수함수가 아닌 사례 

// 1. 밖의 상태에 영향을 받는 상태
// c 가 상수(const)라면 순수함수, 변하는 수라면 순수함수가 아님.
var c = 10;
function add2(a, b) {
    return a + b + c;
}
// 같은 값을 줬다고 항상 같은 값을 반환하지않음. 평가시점이 중요한 함수
console.log( add2(10, 5) )


// 2. 외부에 부수효과를 일으키는 함수 
// - 들어온 인자에 상태를 직접 변경하는 
// - 외부의 값을 변경하는 
var c = 20;
function add3(a, b) {
    c = b;
    return a + b;
}

console.log('prev c: ', c)
console.log( add3(3, 5) )
console.log('next c: ', c)


// 3. 인자로 들어온 값을 직접 변경함.
var obj1 = { val: 10 }
function add4(obj, b) {
    obj.val += b
}
add4(obj1, 20)
console.log( obj1.val )




// 다시 순수함수 
var obj1 = { val: 10 }
function add5(obj, b) {
    return { val: obj.val + b }
}

console.log(obj1.val) //변경없음 10
var obj2 = add5(obj1, 20);
console.log(obj1.val) //변경없음 10
console.log(obj2.val) // 함수는 obj1값을 참조만 해서 더하고 리턴함


</script>


</body>
</html>