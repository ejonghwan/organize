next js 

## page router 

1. _document.tsx 카카오맵같은거 어펜드로 하지말고 여기다 추가? 
2. 다이나믹 라우팅 : test/[...id]/name.tsx -> 배열형태 - 주의 index.tsx 없으면 세그먼트 없이 접근안됨. -> index.tsx 만들거나 [[ ...id ]] 이런식으로 사용 
3. 네비게이팅 렌더링 : 사전 렌더링 때문에 2번 호출 
4. a태그는 이동은 되지만 최적화되지 않은 방법 -> Link * 컴포넌트 마운트 후 요청 코드가 작동하기 떄문에 react는 데이터 패칭 자체가 늦음 (번들 파싱하고 화면 그리고 이후에 패칭 코드 읽고 로딩바 띄우고 ...) 

7. react 렌더링 - 요청 (빈화면) - js 번들 내려줌 (빈화면) - js 번들 파싱 후 필요한 요청 - [FCP] 화면 렌더링 -> 기존 리액트의 문제점은 데이터 패칭 자체가 FCP 끝난 후 요청 소스를 읽기 떄문에 "화면을 그린 후 요청이 들어감" -> 화면 로딩 기다린 후 로딩바 까지 기다리는 상황 -> 때문에 사전 렌더링 / SSR 가능하게 next 지원 

5. next 사전렌더링 - [FCP] : 
1. 화면 렌더링 - [FCP] : 
2. 서버에서 JS번들 파일 받아옴 (프론트 서버요청) - [FCP] : 
3. 번들 파일과 화면 렌더링 소스 하이드레이션 - [TTI] : 
4. 인터렉션 가능해짐 - [TTI] : 
5. route 이동시 페이지이동 요청 (CSR) - [TTI] : 
6. JS 교체 - [TTI] : 7. 페이지 렌더링 6. 프리패칭 - 링크된 페이지 라우터를 모두 미리 불러놓는 기능. (내가 알기론 빌드할 때 만드는걸로 알고있는데 ..SSG ?) - 빌드단계에서 라우팅별로 스플리팅 해서 만들어둠. 요청 시 그 코드들만 재전달 (클라이언트 안에서 동작하기 떄문에 빠름) - 네트워크탭보면 라우터이동시 각각의 js 파일 다시 받아오는데, 빌드단계를 거치지 않아서임 - 빌드 후 프로덕션모드로 실행하면 모두 다운받음(캐시 없어지면 다시 요청하기도함) 

* Link 컴포넌트에 걸린것만 빌드시점에 프리패칭하기에 button으로 된 건 클릭했을 때 요청함. 
* button이나 router 객체로 연결한건 router.prefetch('/home') 
* Link 에 걸린걸 레이지 패칭시키려면 prefetch 속성 false 

8. 렌더링종류 - SSR -> 요청 시 사전렌더링 (단점 : back이 불안정하면 오래 기다림. 페이지기다리고 데이터도 기다려야됨) - SSG -> 빌드타임에 사전렌더링 (단점 : 빌드타임에만 사전렌더링하기 떄문에 이후엔 사전렌더링 하지않음 ) - ISR -> 빌드타임에 사전렌더링 후 특정 시간 이후 다시 프론트서버에 접속요청오면 요청온 페이지 재생성 후 응답해줌 - 몇초마다 검증 설정가능. - 빌드타임에 설정된 시간동안은 정적파일만 주다가 설정된 시간이 끝나면 검증시간마다 데이터변경시 재요청 - 시간을 기준으로 : 시간을 기준으로 하게 되면 사용자가 수정한 데이터를 바로 반영할 수 없거나 변경하지 않았어도 설정된 시간으로 계속 요청 - 요청을 기준으로 : 시간을 기준으로 정적페이지처럼 작동하지만 요청이온다면 재요청해서 응답해줌 (장점만 연결/SSR보단 성능이 좋음) 

9. window.location - error 나는 이융 : 서버에서 먼저 컴포넌트를 한번 실행하기 떄문에 window객체는 없기 떄문 - app router 기반이면 조건문으로 해결밖에 없나 ? 

10. 페이지 라우터 방식 단점 - 페이지별 레이아웃 번거로움 - 데이터 패칭을 특정함수로 받아서 props으로 내려주는데 이걸 page 에서만 가능함 - 불필요한 하이드레이션 단계. (번들파일 크기 커짐) 




###################################### 렌더링 과정 총 정리 

0. react 렌더링 과정 다시 정리 

1) react server 요청 
2) 빈 html, js 번들파일 내려주고 브라우저가 렌더링 
3) 번들 해석 및 렌더링 
4) 패칭 실행 
5) 로딩바 fcp > tti(상호작용) 늦어짐 

0. next 렌더링 과정 다시 정리 (sc, cc 빼고) 
1) next 서버 요청 1-1) 여기서도 pre-fetching 함 (이단계에서 request 가능. transtack-query prefetch component 인듯) 
2) 초기 필요한(해당페이지) bundle.js만 내려줌 
3) 하이드레이션 
4) 유저 상호작용 가능 
5) pre-fetching (모든 페이지 js) (????) 
6) 페이지 이동 시 요청 (다시 안내려줌x) 
7) js 실행 (컴포넌트) 
8) 페이지 교체 

0. next 렌더링 과정 다시 정리 (sc, cc 포함) 
* server Com은 하이드레이션이 필요없음 => 사전 렌더링 
* client Com은 하이드레이션이 필요함 => 추후 번들로 내려줌 
* page router는 위 두개를 구분하지않음. 번들로 모두 내려줌 (용량 큼) 
* 서버컴포넌트는 next server에 요청이 오면 딱 한번 실행됨 즉, 상호작용이 필요한 컴포넌트는 클라컴포로 만들어서 bundle로 내려주고 그 외 컴포넌트는 서버컴포넌트로 만들어 번들 사이즈를 줄인다 * 때문에 공식문서에서는 대부분은 서버컴포넌트로 구성하고 필요한 부분에만 클라컴포로 만들기를 권장 

* app router에서는 스태틱/동적인 페이지로 구분 되는데, 스태틱은 SSG / 동적인 페이지는 SSR 처럼 사전로드함. SSG : 일반적인 페이지 SSR : 파라미터를 가져오거나 동적으로 만든, 사전 로드하면 안될거같은 페이지들 

1) next server 요청 
2) (pre-fetch단계) server component / client component 각각 한번씩 해석해서 html로 내려줌 <- (이때 back request 있으면 그거도 요청 후 포함해서) 
- 엄밀하게 말하자면 사전렌더링 과정에서 서버컴포넌트가 먼저 실행되고 이 과정에서 RSC payload라는 값이 생김. 

- RSC payload는 모든 값이 직렬화 된건데 function object는 직렬화가 되지 않음 - 서버컴포넌트가 실행 되고 클라이언트 컴포넌트가 실행됨 (때문에 클라컴 자식으로 서버컴이 될수가 없음. 호출 시 강제로 서버컴 -> 클라컴 바꿔버림) 

3) FCP 
4) js 번들 + RSC payload 내려줌 (여기엔 client component만 있고 한번 더 실행됨) 
5) 기존에 내려왔던 html과 하이드레이션해서 상호작용 적용 
6) TTI 0. Link 컴포 안쓰고 router 이용 시 router.prefetch안해주면 프리패칭 안됨 (반대로 Link 프리패칭도 해제할 수 있음) 



0. react는 JS bundle 파일 용량 떄문에 라우팅/컴포넌트를 코드 스플리팅해서 전달하기 떄문에 이동 시 react server로 요청해서 다시 받아옴. 
이걸 안하게 하기 위해 next는 사전렌더링 하는거. 때문에 렌더링 단계 자체가 좀 다름. 


###################################### 렌더링 과정 총 정리 

1. layout.tsx는 children으로 page.tsx를 받음 (중첩돼서 가장 마지막 레이아웃적용이 아니라 쌓임. 덮으려면 그룹핑해줘야됨 ) 
2. server component - 하이드레이션 단계를 


# next js 특징 주의 - 상호작용 가능한 기능 넣으면 안됨 - 의존성 라이브러리가 상호작용 기능이 들어가있다면 역시 에러남 - 클라이언트 컴포넌트는 서버/클라 두 곳에서 실행된다는 것 명심 

1)서버컴포에서 사전렌더링때 1번 
2)클라 컴포에서 하이드레이션 할 떄 1번 
3)총 2번 실행 - 클라 컴포에서 서버 컴포 임폴트 불가 

1)이유 : 서버 컴포는 서버에서만 실행되기 떄문. 서버컴포 소스는 없기 떄문(하이드레이션 단계 번들 파일에 존재 하지 않음) 
2)하지만 에러는 나지 않음. 서버컴포를 클라컴포로 변경해버림 - 서버 컴포에서 클라컴포에게 직렬화 되지 않은 props는 전달 불가능함 

1) 직렬화 (serialization) 
2) js Fn객체는 직렬화 불가능함 (그럼 setter함수는 왜 넘어가짖 ? ) 


###################################### next fetch cache next js fetch 캐시 관련 

1. const res = await fetch('api', { cache: "force-cache" }) // 한번 호출 된 이후 캐시함. 다시 호출안함 
2. "" { cache: "no-store" } // 캐시 안함 (기본값) 
3. next: { revalidate: 10 } // 특정 시간 이후 업데이트해줌. ISR 같은거 
4. next : { tags: ['str'] } // 요청이 들어왔을 때에만 최신화 ---- request memoization 

1. 여러 컴포넌트에서 request를 모아서 같은건 두번 요청하지않는 넥스트기능. 자동으로 해줌 
2. 요청 소스를 만나면 request memo라는 공간에 캐시해둠. 같은 요청이 왔을 때 캐시공간을 보는게 아니라 reqeust memo 공간에서 꺼내옴 
3. fetch cache랑은 다름. 렌더링이 종료가 되면 모든 캐시가 소멸됨. (중요) 4. 3번 떄문에 렌더링 이후 request는 중복해서 가져올 수 있음 


###################################### 풀 라우트 캐시 

* 단계 (static) [NEXT SERVER] | [BACK] (full route cache) (pre-fetch) (reuqest memo) (data cache) | A 요청 -> -> -> -> 뒤 과정들 다 돌고 set <- B 요청 -> <- 풀 라우트 캐시에서 꺼내옴 * 단계 (dynamic) full route cache 공간에 저장하지 않고 위 단계 계속 반복 (querystring 사용하는 search / auth cookie 검증 등 어쩔 수 없는경우에는 필요) * 풀라우트 캐시 + 데이터 캐시 같이 사용 = ISR같은 애 A 요청 시 [풀라우트 캐시] > [사전렌더링] > [리퀘스트 메모] > [데이터 캐싱] > [백] 모두 돈 후 [풀라우트 캐시]에 저장 B 요청 시 fetch('api', { revalidate: 3 }) 설정 후 3초 이후 stale 상태일 때 우선 [풀라우트 캐시]에서 상한 데이터 꺼내서 렌더링 이후 빠르게 최신 데이터를 가져와 [데이터 캐싱] [풀라우트 캐시] 부분에 최신화 시키고 렌더링 

1. 풀 라우트 캐시 - build time 에서 사전로드 하는 기능(api 요청도 포함해서) = SSG같은 애임 - 컴포넌트는 static / dynamic 두 가지가 존재 - 생성되는 과정은 

1) 서버 컴포넌트 중, 요청이 있을 것 같은 페이지는 다이나믹 페이지, 요청이 없다면 스태틱 페이지 
- fetch (no-cache거나) 
- cookie / header / query string 등을 꺼내오는 기능이 있는 컴포넌트를 포함하는 모든 페이지 
- 동적 함수 없고 데이터 요청이 있지만 캐싱(force-store) 설정이 되어있다면 static component에 포함 

2. query string 받는 곳이나 다이나믹라우팅 페이지들은 풀 라우트 캐시를 사용하지 못함. (때문에 data cache 이용) 하지만 특정 params 등만 풀 라우트 캐시를 설정할 수 있음 - 혹은 정적인 params 받는 설정 => generateSteicParams() 함수임 export generateSteicParams = () => { return [{ id: "1" }, { id: "2" }, { id: "3" }] } 이렇게 설정하면 build time에 1,2,3 동적 라우팅 페이지들은 풀라우트캐싱 처리됨 * generateSteicParams 함수 사용하면 request가 있더라도 static 페이지로 아예 고정됨 * 1,2,3 외 다른 id 요청이 들어가도 라우트캐시에 저장이 자동으로 됨 (.next 캐시폴더에 추가됨) - 근데 id:4로 왔을 떄도 렌더링이 되어버림. export const dynamicParams = false 해줘야 404로 이동 


###################################### 
클라이언트 캐시 페이지 이동 시 라우터는 넥스트 client server에 있는 풀라우트캐시로 요청하지 않고 client(브라우저) 에 캐시를 저장 후 그 데이터를 가져와서 뿌린다 



###################################### 
요청 후 ssr 에서 실행안되게 하는 useSearchParams hook은 비동기로 작동. 
클라이언트 훅인데 서버컴포넌트에서 실행되기 떄문에 에러가 나는데, 내꺼에선 안남 next server에서 실행 안되게 하는 방법 

1. window check 
2. Suspence 감싸기 => 서스펜스는 SSR에서 실행하지 않는 게 아니라 실행은 하는데 화면만 렌더링 하지 않는다는 의미 


###################################### 
스트리밍 back에서 큰 데이터를 처리할 때 오래걸릴 것 같으면 조각조각내어 완료된거부터 연속적으로 전달하는 기법 nextjs에선 먼저 완료된 컴포넌트부터 보내주고 비동기 포함되어 있는 작업이나 오래 걸리는 작업은 천천히 보내줌 주의 

1 ) 스트리밍 적용된 page.tsx 하위 경로에 있는 라우터들은 모두 같이 적용됨 주의 
2 ) 비동기 컴포넌트만 적용됨 주의 
3 ) page.tsx에만 적용가능함 (layout components 모두 적용안됨. Suspense 사용) 

## 컴포넌트를 스트리밍 하고 싶다면 아래 컴포넌트 사용 - (로딩보단 서스펜스 많이 사용) Suspense 팁 : query string 변경 시 로딩 상태 주고 싶으면 Suspense props 값 중 key 쓰면 됨 ex) 


###################################### 
dynamic router => 앵간하면 옵션 사용하지않는게 좋음. 충돌or관리 떄문에 특정 페이지를 강제로 static / dynamic 으로 변경해줌 export const dynamic = 'auto' => 암것도안함 export const dynamic = 'force-dynamic' => 강제 dynamic export const dynamic = 'force-static' => 강제 static export const dynamic = 'error' => 강제 static 페이지로 변경하지만, 동적 함수같은게 있다면 build 시 오류 발생 동적 함수인 useSearchParams 에서 query string을 가져오는 컴포넌트에서 'force-static' 옵션을 키면 강제 스태틱 페이지가 되기 떄문에 query string을 가져올 수 없음. 컴포넌트 내에서도 가능하고 import 할 떄도 가능 

###################################### 
이미지 도메인 다르면 next.config > domain: [] 설정 


###################################### 
seo 
1. 사이트맵 설정 
2. rss발행 
3. 시멘틱 
4. 메타데이터 동적인 메타데이터 설정법 page.tsx에서 아래 함수 사용. 이미 선언된 함수임. 비동기 promise 리턴. component랑 같게 query string props로 받기 가능 


export const genaratorMetadata({ searchParams: Promise<{ q: string || '' }> }): Promise